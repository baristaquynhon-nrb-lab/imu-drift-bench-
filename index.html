<!DOCTYPE html><html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CPL + ΔS — IMU Zero‑Drift (Gyro Bias)</title>
  <style>
    body{font-family:ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; margin:0; padding:24px; background:#0b1020; color:#e7ecff}
    .card{background:#121734; border:1px solid #1f2752; border-radius:16px; padding:16px; box-shadow:0 8px 24px rgba(0,0,0,0.35); margin:auto; max-width:860px}
    h1{font-weight:700; font-size:22px; margin:0 0 12px}
    .row{display:flex; gap:12px; flex-wrap:wrap}
    button{background:#2a60ff; color:#fff; border:none; border-radius:12px; padding:10px 14px; cursor:pointer; font-weight:600}
    button.secondary{background:#263155}
    button:disabled{opacity:0.6; cursor:not-allowed}
    .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}
    .pill{display:inline-block; background:#0f1a3d; border:1px solid #263155; padding:4px 8px; border-radius:999px; font-size:12px}
    .log{background:#0f1430; border:1px dashed #2a335e; border-radius:12px; padding:10px; height:200px; overflow:auto}
  </style>
</head>
<body>
  <div class="card">
    <h1>① IMU Zero‑Drift (Gyro Bias) <span class="pill">Phone stays still</span></h1>
    <p>Measure slow <b>bias drift</b> of the gyroscope while the phone is stationary. ΔS (condition): <span class="mono">batteryLevel, charging</span>. Phenomenon: accumulated angle error from <span class="mono">rotationRate</span>.</p>
    <div class="row">
      <button id="imuStart">Start IMU</button>
      <button id="imuStop" class="secondary" disabled>Stop</button>
      <button id="imuExport" class="secondary" disabled>Export CSV</button>
    </div>
    <div id="imuSummary" class="mono" style="margin:8px 0 8px; min-height:24px"></div>
<div id="imuStatus" class="mono" style="opacity:.9; font-size:12px; min-height:18px"></div>
    <div class="log mono" id="imuLog"></div>
    <p class="mono" style="opacity:.8; font-size:12px; margin-top:10px">Tip: In Chrome → Settings → Site settings → <b>Motion sensors</b> → Allow. Open this file in <b>Chrome</b> over <b>HTTPS</b> (or <b>localhost</b>) — many browsers block sensors on <span class="mono">file://</span>.</p>
  </div><script>
// ===== Utilities =====
function csvEscape(v){ if (v==null) return ""; const s = typeof v === "string" ? v : JSON.stringify(v); return '"' + s.replaceAll('"','""') + '"'; }
function downloadCSV(rows, name){
  const header = "epoch_ms,test_id,cond_json,phenomenon_json\n";
  const body = rows.map(r=> [r.t, r.id, csvEscape(r.cond), csvEscape(r.phen)].join(',')).join('\n');
  const blob = new Blob([header+body], {type:'text/csv'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = name; a.click(); URL.revokeObjectURL(a.href);
}
function linfit(xs, ys){
  const n = xs.length; if (n < 2) return {m: NaN, b: NaN};
  let sx=0, sy=0, sxx=0, sxy=0; for (let i=0;i<n;i++){ const x=xs[i], y=ys[i]; sx+=x; sy+=y; sxx+=x*x; sxy+=x*y; }
  const d = n*sxx - sx*sx; if (!d) return {m: NaN, b: NaN};
  const m = (n*sxy - sx*sy) / d; const b = (sy - m*sx) / n; return {m,b};
}
function fmt(x, d=3){ return (isFinite(x)? x.toFixed(d) : 'NA'); }

// ===== IMU module =====
let battery = null;
async function getBatteryInfo(){
  try{
    if (navigator.getBattery){
      battery = await navigator.getBattery();
    }
  }catch(e){ battery = null; }
}
const imuRows = [];
let imuRunning = false;
let imuLog = document.getElementById('imuLog');

let imuStatus = document.getElementById('imuStatus');
let imuPath = 'unknown'; // 'GS' or 'DM' or 'none'
let lastEventTs = 0;
function setStatus(msg){ imuStatus.textContent = msg; }

let imuSummary = document.getElementById('imuSummary');
let imuStartBtn = document.getElementById('imuStart');
let imuStopBtn = document.getElementById('imuStop');
let imuExportBtn = document.getElementById('imuExport');

let lastT = null; // ms
let biasWin = []; // rolling window (deg/s)
const BIAS_MS = 5000; // 5s bias learning window
let bias = {a:0,b:0,g:0}; // deg/s
let angle = {a:0,b:0,g:0}; // deg

let gs = null; // Generic Sensor Gyroscope
let dmHandler = null; // DeviceMotion fallback

function pushBias(om){
  const t = Date.now();
  biasWin.push({t, a:om.a, b:om.b, g:om.g});
  const cut = t - BIAS_MS; while(biasWin.length && biasWin[0].t < cut) biasWin.shift();
  const n = biasWin.length || 1;
  bias.a = biasWin.reduce((s,x)=>s+x.a,0)/n;
  bias.b = biasWin.reduce((s,x)=>s+x.b,0)/n;
  bias.g = biasWin.reduce((s,x)=>s+x.g,0)/n;
}

function handleOmega(omega){ // deg/s
  const now = Date.now();
  if (lastT === null) lastT = now;
  const dtRaw = (now - lastT)/1000; // s
  const dt = Math.min(Math.max(dtRaw, 0), 0.1); // clamp to [0,0.1] s
  lastT = now;
  pushBias(omega);
  const oa = omega.a - bias.a, ob = omega.b - bias.b, og = omega.g - bias.g;
  angle.a += oa * dt; angle.b += ob * dt; angle.g += og * dt;
  return {dt, oa, ob, og};
}

async function ensureMotionPermission(){
  try {
    if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function'){
      const resp = await DeviceMotionEvent.requestPermission();
      if (resp !== 'granted') throw new Error('Motion permission denied');
    }
  } catch(e) { /* ignore if not supported */ }
}

function updateSummaryAndLog(){
  if (imuRows.length < 10) return;
  const t0 = imuRows[0].t;
  const xs = imuRows.map(r => (r.t - t0)/1000);
  const ysA = imuRows.map(r => r.phen.alpha_deg);
  const ysB = imuRows.map(r => r.phen.beta_deg);
  const ysG = imuRows.map(r => r.phen.gamma_deg);
  const fa = linfit(xs, ysA), fb = linfit(xs, ysB), fg = linfit(xs, ysG);
  imuSummary.textContent = `drift α=${fmt(fa.m)} deg/s, β=${fmt(fb.m)} deg/s, γ=${fmt(fg.m)} deg/s | bias(dps) ${fmt(bias.a)},${fmt(bias.b)},${fmt(bias.g)}`;
  imuLog.textContent = `n=${imuRows.length}\nangle(deg) α=${fmt(angle.a,2)} β=${fmt(angle.b,2)} γ=${fmt(angle.g,2)}`;
}

imuStartBtn.onclick = async () => {
  try{
    imuRows.length = 0; imuLog.textContent = ''; imuSummary.textContent = '';
    angle = {a:0,b:0,g:0}; bias = {a:0,b:0,g:0}; biasWin=[]; lastT=null;
    await getBatteryInfo();
    await ensureMotionPermission();
    setStatus('Waiting for sensor events…');
    imuRunning = true;

    // 3s watchdog: if no sensor events, show diagnostic
    const startTs = Date.now();
    setTimeout(()=>{
      if (imuRows.length === 0 || (Date.now() - lastEventTs) > 2500){
        let tips = [
          'No sensor events detected. Likely cause: opened via file manager (content:// or file://).',
          'Open in Chrome over HTTPS or http://localhost (Termux or a local server).',
          'In Chrome → Site settings → Motion sensors → Allow.',
          'On some devices, only DeviceMotion is available — Generic Sensor API may be blocked.'
        ].join(' ');
        setStatus(tips + ' [path='+imuPath+']');
      } else {
        setStatus('Sensor events OK. Using path='+imuPath);
      }
    }, 3000);


    let useGS = ('Gyroscope' in window) && (typeof Gyroscope === 'function');
    
if (useGS){
  try {
    gs = new Gyroscope({frequency:50});
    gs.addEventListener('reading', ()=>{
      if (!imuRunning) return;
      // rad/s -> deg/s
      const omega = { a: gs.x * 180/Math.PI, b: gs.y * 180/Math.PI, g: gs.z * 180/Math.PI };
      const {dt} = handleOmega(omega);
      lastEventTs = Date.now();
      const t = Date.now();
      const cond = { batteryLevel: battery? battery.level : null, charging: battery? battery.charging : null };
      const phen = { alpha_dps: omega.a, beta_dps: omega.b, gamma_dps: omega.g, alpha_deg: angle.a, beta_deg: angle.b, gamma_deg: angle.g, dt_s: dt, bias_a:bias.a, bias_b:bias.b, bias_g:bias.g };
      imuPath = 'GS';
      imuRows.push({t, id:'IMU_GYRO_GS', cond, phen});
      if (imuRows.length % 10 === 0) updateSummaryAndLog();
    });
    gs.start();
  } catch(e){
    console.warn('Gyroscope init failed, fallback to DeviceMotion:', e);
    useGS = false;
  }
}
if (!useGS){
  dmHandler = (ev)=>{
    if (!imuRunning || !ev.rotationRate) return;
    const rr = ev.rotationRate;
    const omega = { a: rr.alpha || 0, b: rr.beta || 0, g: rr.gamma || 0 }; // deg/s
    const {dt} = handleOmega(omega);
      lastEventTs = Date.now();
    const t = Date.now();
    const cond = { batteryLevel: battery? battery.level : null, charging: battery? battery.charging : null };
    const phen = { alpha_dps: omega.a, beta_dps: omega.b, gamma_dps: omega.g, alpha_deg: angle.a, beta_deg: angle.b, gamma_deg: angle.g, dt_s: dt, bias_a:bias.a, bias_b:bias.b, bias_g:bias.g };
    imuPath = 'DM';
    imuRows.push({t, id:'IMU_GYRO_DM', cond, phen});
    if (imuRows.length % 10 === 0) updateSummaryAndLog();
  };
  window.addEventListener('devicemotion', dmHandler);
}
imuStartBtn.disabled = true; imuStopBtn.disabled = false; imuExportBtn.disabled = true;
    imuLog.textContent = 'Running… keep phone still for ~5s to learn bias.';
  }catch(err){ alert('IMU error: '+err.message); }
};

imuStopBtn.onclick = ()=>{
  imuRunning = false; lastT = null;
  try{ if (gs){ gs.stop(); gs = null; } }catch(e){}
  if (dmHandler){ window.removeEventListener('devicemotion', dmHandler); dmHandler = null; }
  imuStopBtn.disabled = true; imuStartBtn.disabled = false; imuExportBtn.disabled = (imuRows.length===0);
  if (imuRows.length) updateSummaryAndLog();
  imuLog.textContent += '\nStopped. You can export CSV.';
};

imuExportBtn.onclick = ()=> downloadCSV(imuRows, `cpl_imu_drift_${new Date().toISOString().slice(0,19)}.csv`);
</script></body>
</html>